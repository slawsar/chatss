<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat SS</title>
    <!-- Add Marked.js for Markdown parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.3.0/marked.min.js"></script>
    <!-- Add Highlight.js for code syntax highlighting -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/github.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <style>
:root {
        --primary-color: #4a6fff;
        --secondary-color: #8a96fd;
        --text-color: #333;
        --bg-color: #fff;
        --border-color: #e0e0e0;
        --user-msg-bg: #f0f5ff;
        --model-msg-bg: #f9f9f9;
        --sidebar-bg: #f5f7ff;
        --input-bg: #fff;
        --transition-speed: 0.3s;
        --code-bg: #f6f8fa;
        --blockquote-border: #dfe2e5;
        --blockquote-bg: #f6f8fa;
        --table-border: #dfe2e5;
        --table-header-bg: #f6f8fa;
        --star-inactive: #d4d4d4;
        --star-active: #FFD700;
        --best-answer-bg: #f0fff0;
        --best-answer-border: #4CAF50;
    }

    [data-theme="dark"] {
        --primary-color: #5d7fff;
        --secondary-color: #6a7aff;
        --text-color: #e0e0e0;
        --bg-color: #1a1a1a;
        --border-color: #444;
        --user-msg-bg: #2d3757;
        --model-msg-bg: #2a2a2a;
        --sidebar-bg: #252836;
        --input-bg: #2a2a2a;
        --code-bg: #2d2d2d;
        --blockquote-border: #444;
        --blockquote-bg: #2d2d2d;
        --table-border: #444;
        --table-header-bg: #2d2d2d;
        --star-inactive: #555;
        --star-active: #FFD700;
        --best-answer-bg: #1e3320;
        --best-answer-border: #4CAF50;
    }

    /* Poprawki responsywno≈õci i przewijania */
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        transition: background-color var(--transition-speed), color var(--transition-speed);
    }

    body {
        background-color: var(--bg-color);
        color: var(--text-color);
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden; /* Zablokuj przewijanie ca≈Çej strony */
    }

    .main-container {
        display: flex;
        height: calc(100vh - 60px); /* Odejmij wysoko≈õƒá nawigacji */
        overflow: hidden;
    }

    .sidebar {
        width: 300px;
        max-height: 100%;
        overflow-y: auto;
        flex-shrink: 0;
        background-color: var(--sidebar-bg);
        border-right: 1px solid var(--border-color);
        padding: 15px;
        display: flex;
        flex-direction: column;
        scrollbar-width: thin;
        scrollbar-color: var(--primary-color) var(--sidebar-bg);
    }

    .sidebar::-webkit-scrollbar {
        width: 8px;
    }

    .sidebar::-webkit-scrollbar-track {
        background: var(--sidebar-bg);
    }

    .sidebar::-webkit-scrollbar-thumb {
        background-color: var(--primary-color);
        border-radius: 4px;
    }

    .chat-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
        max-height: 100%;
    }

    .view-mode-container {
        flex-shrink: 0;
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 20px;
        scrollbar-width: thin;
        scrollbar-color: var(--primary-color) var(--bg-color);
    }

    .chat-messages::-webkit-scrollbar {
        width: 8px;
    }

    .chat-messages::-webkit-scrollbar-track {
        background: var(--bg-color);
    }

    .chat-messages::-webkit-scrollbar-thumb {
        background-color: var(--primary-color);
        border-radius: 4px;
    }

    .comparison-container {
        flex: 1;
        overflow-x: auto;
        overflow-y: hidden;
        display: flex;
        flex-direction: column;
        max-height: 100%;
        padding: 20px;
    }

    .chat-input-container {
        flex-shrink: 0;
        padding: 15px 20px;
        border-top: 1px solid var(--border-color);
        background-color: var(--bg-color);
    }

    /* Responsywno≈õƒá dla mniejszych ekran√≥w */
    @media (max-width: 992px) {
        .main-container {
            flex-direction: column;
            height: 100vh;
        }
        
        .sidebar {
            width: 100%;
            max-height: 250px;
            order: 1;
        }
        
        .chat-container {
            flex: 1;
            order: 2;
            max-height: calc(100vh - 250px);
        }
    }

    /* Poprawa widoczno≈õci podczas generowania odpowiedzi */
    #stop-generation-container {
        position: sticky;
        bottom: 0;
        z-index: 10;
        background-color: var(--bg-color);
        margin-top: 10px;
        padding: 10px;
        border-top: 1px solid var(--border-color);
    }

    .comparison-container .user-query {
        position: sticky;
        top: 0;
        z-index: 10;
        margin-bottom: 15px;
    }

    /* Reszta oryginalnych styl√≥w */
    nav {
        display: flex;
        align-items: center;
        padding: 15px 20px;
        background-color: var(--bg-color);
        border-bottom: 1px solid var(--border-color);
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .logo {
        font-size: 1.5rem;
        font-weight: bold;
        color: var(--primary-color);
        margin-right: 30px;
    }

    .nav-section {
        display: flex;
        align-items: center;
        margin-right: 20px;
    }

    .api-key-input {
        padding: 8px 12px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        font-size: 14px;
        background-color: var(--input-bg);
        color: var(--text-color);
        width: 250px;
    }

    .api-status {
        margin-left: 10px;
        font-size: 14px;
        opacity: 0.8;
    }

    .theme-toggle {
        margin-left: auto;
        cursor: pointer;
        padding: 5px 10px;
        border: 1px solid var(--border-color);
        border-radius: 4px;
        background-color: var(--input-bg);
        color: var(--text-color);
    }

    .sidebar-heading {
        font-size: 1.2rem;
        margin-bottom: 15px;
        font-weight: 600;
    }

    .model-list {
        list-style: none;
        flex: 1;
    }

    .model-item {
        padding: 8px 12px;
        margin-bottom: 6px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background-color: var(--bg-color);
        cursor: pointer;
        position: relative;
        display: flex;
        align-items: center;
        justify-content: space-between;
        transition: all 0.2s;
    }

    .model-item.selected {
        border-color: var(--primary-color);
        background-color: rgba(74, 111, 255, 0.05);
    }
    
    .model-item.free {
        border-left: 4px solid #4CAF50;
    }

    .model-name {
        font-weight: 600;
        flex: 1;
        font-size: 12px;
        white-space: normal;
        line-height: 1.2;
        max-height: 2.4em;
        overflow: visible;
        padding-right: 6px;
    }

    .checkbox-container {
        flex-shrink: 0;
        margin-left: 4px !important;
    }

    .history-clear, .history-export {
        margin-top: 20px;
        padding: 8px 15px;
        background-color: var(--bg-color);
        color: var(--text-color);
        border: 1px solid var(--border-color);
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s;
    }

    .history-clear:hover, .history-export:hover {
        background-color: rgba(74, 111, 255, 0.1);
    }

    .message {
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
    }

    .message-header {
        font-weight: 600;
        font-size: 14px;
        margin-bottom: 8px;
        color: var(--primary-color);
    }

    .message-content {
        padding: 12px 16px;
        border-radius: 8px;
        line-height: 1.5;
        max-width: 85%;
    }

    .user-message .message-content {
        background-color: var(--user-msg-bg);
        align-self: flex-end;
        border-bottom-right-radius: 0;
    }

    .model-message .message-content {
        background-color: var(--model-msg-bg);
        align-self: flex-start;
        border-bottom-left-radius: 0;
    }

    .chat-input {
        width: 100%;
        padding: 12px 16px;
        border-radius: 8px;
        border: 1px solid var(--border-color);
        background-color: var(--input-bg);
        color: var(--text-color);
        font-size: 16px;
        resize: none;
        min-height: 80px;
        max-height: 200px;
        outline: none;
    }

    .send-button {
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 10px;
        padding: 10px 20px;
        background-color: var(--primary-color);
        color: white;
        border: none;
        border-radius: 6px;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.2s;
    }

        .send-button:hover {
            background-color: var(--secondary-color);
        }

        .send-button:disabled {
            background-color: var(--border-color);
            cursor: not-allowed;
        }

        .typing-indicator {
            display: inline-block;
            margin-left: 5px;
        }

        .dot {
            display: inline-block;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: white;
            margin-right: 3px;
            animation: typing 1.5s infinite ease-in-out;
        }

        .dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
            }
            30% {
                transform: translateY(-5px);
            }
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color);
        }

        .tab {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: border-color 0.2s;
        }

        .tab.active {
            border-bottom-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* Markdown styles */
        .markdown-content {
            line-height: 1.6;
        }

        .markdown-content h1, 
        .markdown-content h2, 
        .markdown-content h3, 
        .markdown-content h4, 
        .markdown-content h5, 
        .markdown-content h6 {
            margin-top: 1.5em;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .markdown-content h1 {
            font-size: 1.8em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
        }

        .markdown-content h2 {
            font-size: 1.5em;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.3em;
        }

        .markdown-content h3 {
            font-size: 1.3em;
        }

        .markdown-content h4 {
            font-size: 1.2em;
        }

        .markdown-content p {
            margin-bottom: 1em;
        }

        .markdown-content ul, 
        .markdown-content ol {
            margin-top: 0.5em;
            margin-bottom: 1em;
            padding-left: 2em;
        }

        .markdown-content li {
            margin-bottom: 0.3em;
        }

        .markdown-content blockquote {
            border-left: 4px solid var(--blockquote-border);
            padding: 0.5em 1em;
            margin: 1em 0;
            background-color: var(--blockquote-bg);
            border-radius: 0 4px 4px 0;
        }

        .markdown-content code {
            font-family: 'Courier New', Courier, monospace;
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 0.9em;
            background-color: var(--code-bg);
            border-radius: 3px;
        }

        .markdown-content pre {
            background-color: var(--code-bg);
            border-radius: 6px;
            padding: 1em;
            overflow: auto;
            margin: 1em 0;
        }

        .markdown-content pre code {
            background-color: transparent;
            padding: 0;
            margin: 0;
            font-size: 0.9em;
            overflow-wrap: normal;
            white-space: pre;
        }

        .markdown-content a {
            color: var(--primary-color);
            text-decoration: none;
        }

        .markdown-content a:hover {
            text-decoration: underline;
        }

        .markdown-content img {
            max-width: 100%;
            border-radius: 4px;
            margin: 1em 0;
        }

        .markdown-content table {
            border-collapse: collapse;
            width: 100%;
            margin: 1em 0;
        }

        .markdown-content table th, 
        .markdown-content table td {
            border: 1px solid var(--table-border);
            padding: 8px 12px;
        }

        .markdown-content table th {
            background-color: var(--table-header-bg);
            font-weight: 600;
        }

        .markdown-content table tr:nth-child(even) {
            background-color: rgba(0, 0, 0, 0.02);
        }

        [data-theme="dark"] .markdown-content table tr:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.02);
        }

        /* File upload styles */
        .file-upload-container {
            display: flex;
            margin-top: 10px;
            align-items: center;
        }

        .file-upload-button {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background-color: var(--bg-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
            margin-right: 10px;
        }

        .file-upload-button:hover {
            background-color: rgba(74, 111, 255, 0.1);
        }

        .file-upload-input {
            display: none;
        }

        .file-list {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .file-item {
            position: relative;
            width: 80px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            background-color: var(--bg-color);
        }

        .file-thumbnail {
            width: 100%;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.03);
        }

        [data-theme="dark"] .file-thumbnail {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .file-thumbnail img {
            max-width: 100%;
            max-height: 100%;
        }

        .file-icon {
            font-size: 26px;
            color: var(--primary-color);
        }

        .file-name {
            font-size: 10px;
            padding: 4px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .file-remove {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 16px;
            height: 16px;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 10px;
            color: #f44336;
        }

        .file-upload-info {
            font-size: 12px;
            color: var(--text-color);
            opacity: 0.7;
        }

        /* Files in messages */
        .message-files {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .message-file {
            width: 100px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
            background-color: var(--bg-color);
            cursor: pointer;
        }

        .message-file-thumbnail {
            width: 100%;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(0, 0, 0, 0.03);
        }

        [data-theme="dark"] .message-file-thumbnail {
            background-color: rgba(255, 255, 255, 0.03);
        }

        .message-file-thumbnail img {
            max-width: 100%;
            max-height: 100%;
        }

        .message-file-icon {
            font-size: 30px;
            color: var(--primary-color);
        }

        .message-file-name {
            font-size: 11px;
            padding: 4px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        @media (max-width: 992px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                max-height: 250px;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
            }

            nav {
                flex-wrap: wrap;
            }

            .nav-section {
                margin-bottom: 10px;
            }

            .api-key-input {
                width: 180px;
            }

            .theme-toggle {
                margin-left: 0;
            }
            
            .comparison-container {
                flex-direction: column;
            }
            
            .comparison-column {
                width: 100% !important;
                margin-right: 0 !important;
                margin-bottom: 15px;
            }
        }

        @media (max-width: 576px) {
            .nav-section {
                flex: 1 0 100%;
                margin-bottom: 10px;
            }

            .logo {
                margin-bottom: 10px;
            }

            .api-key-input {
                width: 100%;
            }
        }

        .security-warning {
            padding: 10px;
            background-color: rgba(255, 242, 171, 0.3);
            border: 1px solid #fff2ab;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 12px;
            line-height: 1.4;
        }

        [data-theme="dark"] .security-warning {
            background-color: rgba(255, 242, 171, 0.1);
        }

        .warning-icon {
            color: #e6b800;
            margin-right: 5px;
        }

        .checkbox-container {
            display: block;
            position: relative;
            padding-left: 35px;
            margin-bottom: 12px;
            cursor: pointer;
            font-size: 12px;
            user-select: none;
            margin-top: 10px;
        }

        .checkbox-container input {
            position: absolute;
            opacity: 0;
            cursor: pointer;
            height: 0;
            width: 0;
        }

        .checkmark {
            position: absolute;
            top: 0;
            left: 0;
            height: 20px;
            width: 20px;
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .checkbox-container:hover input ~ .checkmark {
            background-color: var(--model-msg-bg);
        }

        .checkbox-container input:checked ~ .checkmark {
            background-color: var(--primary-color);
        }

        .checkmark:after {
            content: "";
            position: absolute;
            display: none;
        }

        .checkbox-container input:checked ~ .checkmark:after {
            display: block;
        }

        .checkbox-container .checkmark:after {
            left: 7px;
            top: 3px;
            width: 5px;
            height: 10px;
            border: solid white;
            border-width: 0 2px 2px 0;
            transform: rotate(45deg);
        }

        .loading {
            display: inline-block;
            position: relative;
            width: 20px;
            height: 20px;
            margin-left: 10px;
        }

        .loading:after {
            content: " ";
            display: block;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid var(--primary-color);
            border-color: var(--primary-color) transparent var(--primary-color) transparent;
            animation: loading 1.2s linear infinite;
        }

        @keyframes loading {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        /* Comparison view styles */
        .view-mode-container {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            background-color: var(--bg-color);
            padding: 5px 10px;
        }
        
        .view-mode-button {
            padding: 6px 10px;
            margin-right: 10px;
            cursor: pointer;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
            transition: all 0.2s;
        }
        
        .view-mode-button.active {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .comparison-container {
            display: flex;
            padding: 20px;
            overflow-x: auto;
            flex-wrap: nowrap;
        }
        
        .comparison-column {
            flex: 1;
            min-width: 300px;
            margin-right: 15px;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
        }
        
        .comparison-column-header {
            padding: 10px;
            font-weight: bold;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .comparison-content {
            padding: 10px;
            background-color: var(--model-msg-bg);
            border-radius: 8px;
            flex: 1;
            overflow-y: auto;
            max-height: calc(100vh - 300px);
        }
        
        .model-response-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            padding: 5px 0;
        }
        
        .rating-stars {
            display: flex;
        }
        
        .star {
            cursor: pointer;
            font-size: 20px;
            color: var(--star-inactive);
            margin-right: 2px;
            transition: color 0.2s;
        }
        
        .star.active {
            color: var(--star-active);
        }
        
        .best-answer-button {
            padding: 4px 8px;
            background-color: var(--bg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .best-answer-button:hover {
            background-color: rgba(74, 111, 255, 0.1);
        }
        
        .best-answer-button.marked {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        
        .model-response-container.best-answer {
            border: 2px solid var(--best-answer-border);
            background-color: var(--best-answer-bg);
        }
        
        .best-answer-badge {
            background-color: #4CAF50;
            color: white;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
            margin-left: 10px;
        }
        
        .user-query {
            background-color: var(--user-msg-bg);
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            align-self: flex-end;
            max-width: 85%;
            border-bottom-right-radius: 0;
        }
        
        .query-header {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 8px;
            color: var(--primary-color);
        }
        
        /* Mobile responsiveness for comparison view */
        @media (max-width: 768px) {
            .comparison-container {
                flex-direction: column;
            }
            
            .comparison-column {
                width: 100%;
                margin-right: 0;
                margin-bottom: 15px;
                min-width: unset;
            }
        }
		/* Style dla uproszczonej listy modeli */
.model-item {
    padding: 10px 15px;
    margin-bottom: 8px;
    border: 1px solid var(--border-color);
    border-radius: 6px;
    background-color: var(--bg-color);
    cursor: pointer;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: space-between;
    transition: all 0.2s;
}

.model-item:hover {
    background-color: rgba(74, 111, 255, 0.05);
}

.model-item.selected {
    border-color: var(--primary-color);
    background-color: rgba(74, 111, 255, 0.1);
}

.model-item.free {
    border-left: 4px solid #4CAF50;
}

.model-name {
    font-weight: 600;
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    padding-right: 10px;
}

.free-badge {
    position: absolute;
    top: 4px;
    right: 4px;
    background-color: #4CAF50;
    color: white;
    font-size: 8px; /* Zmniejszony rozmiar czcionki */
    padding: 1px 4px; /* Zmniejszony padding */
    border-radius: 8px;
}

/* Niestandardowy tooltip */
.custom-tooltip {
    position: absolute;
    z-index: 1000;
    background-color: var(--bg-color);
    color: var(--text-color);
    padding: 10px 15px;
    border-radius: 6px;
    border: 1px solid var(--border-color);
    font-size: 12px;
    max-width: 300px;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s;
    box-shadow: 0 3px 15px rgba(0,0,0,0.1);
    pointer-events: none;
}
/* Zmiana szeroko≈õci paska bocznego, je≈õli to konieczne */
@media (min-width: 992px) {
    .sidebar {
        width: 420px; /* Lekko zwiƒôkszona szeroko≈õƒá */
    }
}
    /* Style dla ikony informacyjnej */
    .info-icon {
        cursor: pointer;
        margin-left: 8px;
        opacity: 0.6;
        transition: opacity 0.2s;
    }
    
    .info-icon:hover {
        opacity: 1;
    }
    
    /* Style dla modala */
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
    }
    
    .modal-content {
        background-color: var(--bg-color);
        padding: 20px;
        border-radius: 8px;
        max-width: 500px;
        width: 90%;
        max-height: 80%;
        overflow-y: auto;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        position: relative;
    }
    
    .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        cursor: pointer;
        font-size: 24px;
        color: var(--text-color);
        opacity: 0.6;
        transition: opacity 0.2s;
    }
    
    .modal-close:hover {
        opacity: 1;
    }
    
    .modal-header {
        font-size: 1.2em;
        font-weight: bold;
        margin-bottom: 15px;
        color: var(--primary-color);
        border-bottom: 1px solid var(--border-color);
        padding-bottom: 10px;
    }
    
    .modal-details {
        margin-bottom: 15px;
    }
    
    .modal-detail {
        margin-bottom: 10px;
    }
    
    .modal-detail strong {
        display: block;
        margin-bottom: 5px;
        color: var(--secondary-color);
    }
	/* Popraw przewijanie w widoku por√≥wnawczym */
.comparison-container {
    height: calc(100vh - 200px); /* Dostosuj wysoko≈õƒá do ca≈Çkowitej wysoko≈õci ekranu */
    overflow-y: auto; /* W≈ÇƒÖcz przewijanie w pionie */
    overflow-x: auto; /* W≈ÇƒÖcz przewijanie w poziomie */
}

.comparison-column {
    min-width: 300px; /* Minimalna szeroko≈õƒá kolumny */
    max-width: 500px; /* Maksymalna szeroko≈õƒá kolumny */
    flex: 1; /* Pozw√≥l na elastyczne rozciƒÖganie */
    margin-right: 15px; /* Dodaj margines miƒôdzy kolumnami */
}

.comparison-content {
    max-height: none; /* Usu≈Ñ ograniczenie maksymalnej wysoko≈õci */
    overflow-y: auto; /* W≈ÇƒÖcz przewijanie wewnƒÖtrz tre≈õci */
}

/* Responsywno≈õƒá dla mniejszych ekran√≥w */
@media (max-width: 768px) {
    .comparison-container {
        height: auto; /* Automatyczna wysoko≈õƒá na ma≈Çych ekranach */
        flex-direction: column; /* Uk≈Çadaj kolumny pionowo */
        overflow-y: visible;
    }
    
    .comparison-column {
        min-width: 100%; /* Pe≈Çna szeroko≈õƒá na ma≈Çych ekranach */
        max-width: 100%;
        margin-right: 0;
        margin-bottom: 15px;
    }
}
.sort-container {
    margin-bottom: 15px;
    display: flex;
    align-items: center;
}

.sort-select {
    padding: 8px 10px;
    border: 1px solid var(--border-color);
    border-radius: 4px;
    background-color: var(--bg-color);
    color: var(--text-color);
    font-size: 14px;
    width: 100%;
    cursor: pointer;
    outline: none;
}

.sort-select:hover {
    border-color: var(--primary-color);
}
    </style>
</head>
<body>
    <nav>
        <div class="logo">Chat SS</div>
        <div class="nav-section">
            <input type="password" id="api-key" class="api-key-input" placeholder="Wprowad≈∫ klucz API OpenRouter">
            <span class="api-status" id="api-status"></span>
        </div>
        <button id="theme-toggle" class="theme-toggle">üåô / ‚òÄÔ∏è</button>
    </nav>

    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div class="sidebar-heading">Dostƒôpne modele</div>
			<div class="sort-container">
    <select id="model-sort" class="sort-select">
        <option value="default">Domy≈õlne sortowanie</option>
		<option value="free-in-name">Free w nazwie</option>
        <option value="name-asc">Nazwa (A-Z)</option>
        <option value="name-desc">Nazwa (Z-A)</option>
        <option value="price-asc">Cena (rosnƒÖco)</option>
        <option value="price-desc">Cena (malejƒÖco)</option>
    </select>
</div>
            <div class="model-list" id="model-list">
                <!-- Models will be dynamically added here -->
                <div class="loading" id="models-loading"></div>
            </div>
            <div class="security-warning">
                <span class="warning-icon">‚ö†Ô∏è</span>
                <div style="margin-bottom: 8px;">Uwaga: Tw√≥j klucz API jest przechowywany lokalnie w przeglƒÖdarce. Zalecamy u≈ºywanie kluczy testowych lub z ograniczeniami.</div>
                <div id="debug-info" style="font-size: 10px; margin-top: 5px; display: none;"></div>
                <button id="test-connection" class="history-clear" style="margin-top: 10px; display: none;">Test po≈ÇƒÖczenia</button>
            </div>
            <button id="clear-history" class="history-clear">Wyczy≈õƒá historiƒô</button>
            <button id="export-history" class="history-export">Eksportuj historiƒô</button>
        </div>
<div id="model-details-modal" class="modal">
    <div class="modal-content">
        <span class="modal-close">&times;</span>
        <div class="modal-header" id="modal-model-name">Model Details</div>
        <div class="modal-details" id="modal-model-details">
            <!-- Szczeg√≥≈Çy modelu bƒôdƒÖ dynamicznie wstawiane tutaj -->
        </div>
    </div>
</div>
        <div class="chat-container">
            <!-- View mode toggle buttons -->
            <div class="view-mode-container">
                <div class="view-mode-button active" data-view="standard">Widok standardowy</div>
                <div class="view-mode-button" data-view="comparison">Widok por√≥wnawczy</div>
            </div>
            
            <!-- Standard chat view -->
            <div class="chat-messages" id="chat-messages">
                <!-- Historia czatu bƒôdzie wy≈õwietlana tutaj -->
            </div>
            
            <!-- Comparison view (initially hidden) -->
            <div class="comparison-container" id="comparison-container" style="display: none;">
                <!-- Dynamically populated columns will go here -->
            </div>
            
            <div class="chat-input-container">
                <!-- File upload container -->
                <div class="file-list" id="file-list"></div>
                <textarea id="chat-input" class="chat-input" placeholder="Napisz wiadomo≈õƒá..." disabled></textarea>
                <div class="file-upload-container">
                    <label for="file-upload" class="file-upload-button">
                        <span>üìé Dodaj plik</span>
                    </label>
                    <input type="file" id="file-upload" class="file-upload-input" multiple>
                    <span class="file-upload-info" id="file-upload-info"></span>
                </div>
                <button id="send-button" class="send-button" disabled>
                    Wy≈õlij
                    <div class="typing-indicator" id="typing-indicator" style="display: none;">
                        <span class="dot"></span>
                        <span class="dot"></span>
                        <span class="dot"></span>
                    </div>
                </button>
            </div>
        </div>
    </div>

    <script>
        // Constants
        // Mo≈ºliwe endpointy do wypr√≥bowania
        const API_ENDPOINTS = [
            'https://openrouter.ai/api/v1',
            'https://api.openrouter.ai/api/v1',
            // API wymaga autoryzacji przez header Authorization: Bearer API_KEY
            'https://openrouter.ai/api/v1/auth/key' // endpoint do testowania klucza API
        ];
        const STORAGE_KEY_API = 'chat_ss_api_key';
        const STORAGE_KEY_THEME = 'chat_ss_theme';
        const STORAGE_KEY_HISTORY = 'chat_ss_chat_history';
        const STORAGE_KEY_SELECTED_MODELS = 'chat_ss_selected_models';
        const STORAGE_KEY_RATINGS = 'chat_ss_ratings';
        const STORAGE_KEY_BEST_ANSWERS = 'chat_ss_best_answers';
        const STORAGE_KEY_VIEW_MODE = 'chat_ss_view_mode';
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB limit for file uploads

        // DOM Elements
        const apiKeyInput = document.getElementById('api-key');
        const apiStatus = document.getElementById('api-status');
        const themeToggle = document.getElementById('theme-toggle');
        const modelList = document.getElementById('model-list');
        const modelsLoading = document.getElementById('models-loading');
        const chatMessages = document.getElementById('chat-messages');
        const comparisonContainer = document.getElementById('comparison-container');
        const chatInput = document.getElementById('chat-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicator = document.getElementById('typing-indicator');
        const clearHistoryButton = document.getElementById('clear-history');
        const exportHistoryButton = document.getElementById('export-history');
        const testConnectionButton = document.getElementById('test-connection');
        const debugInfo = document.getElementById('debug-info');
        const fileUploadInput = document.getElementById('file-upload');
        const fileList = document.getElementById('file-list');
        const fileUploadInfo = document.getElementById('file-upload-info');
        const viewModeButtons = document.querySelectorAll('.view-mode-button');

        // State
        let apiKey = '';
        let models = [];
        let selectedModels = [];
        let conversationHistory = [];
        let ratings = {}; // Store message ratings by message ID
        let bestAnswers = {}; // Store best answers by query ID
        let isLoading = false;
        let uploadedFiles = []; // Array to store the uploaded files
        let currentViewMode = 'standard'; // 'standard' or 'comparison'
		let streamController = null; // AbortController do anulowania strumieniowania
let isStreaming = false; // Flaga wskazujƒÖca czy strumieniowanie jest aktywne

        // Initialize
        document.addEventListener('DOMContentLoaded', initialize);

        function initialize() {
            loadTheme();
            loadApiKey();
            loadSelectedModels();
            loadConversationHistory();
            loadRatings();
            loadBestAnswers();
            loadViewMode();
            
            // Configure Marked options
            marked.setOptions({
                highlight: function(code, lang) {
                    if (lang && hljs.getLanguage(lang)) {
                        try {
                            return hljs.highlight(code, { language: lang }).value;
                        } catch (e) {
                            console.error(e);
                        }
                    }
                    return hljs.highlightAuto(code).value;
                },
                breaks: true,
                gfm: true
            });
            
            // Event listeners
            apiKeyInput.addEventListener('blur', handleApiKeyChange);
            apiKeyInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    apiKeyInput.blur();
                }
            });
            
            themeToggle.addEventListener('click', toggleTheme);
            
            chatInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    sendMessage();
                }
            });
            
            sendButton.addEventListener('click', sendMessage);
            clearHistoryButton.addEventListener('click', clearHistory);
            exportHistoryButton.addEventListener('click', exportHistory);
            testConnectionButton.addEventListener('click', testAPIConnection);

            // File upload handler
            fileUploadInput.addEventListener('change', handleFileUpload);

            // Auto-resize textarea
            chatInput.addEventListener('input', () => {
                chatInput.style.height = 'auto';
                chatInput.style.height = (chatInput.scrollHeight) + 'px';
            });
            
            // View mode toggle
            viewModeButtons.forEach(button => {
                button.addEventListener('click', () => {
                    const viewMode = button.getAttribute('data-view');
                    setViewMode(viewMode);
                });
            });
			// WewnƒÖtrz funkcji initialize()
document.getElementById('model-sort').addEventListener('change', function() {
    sortModels(this.value);
});
			initTooltips();
        }

function initTooltips() {
    // Tworzenie elementu tooltipa
    const tooltip = document.createElement('div');
    tooltip.className = 'custom-tooltip';
    document.body.appendChild(tooltip);

    // Dodanie nas≈Çuchiwania zdarze≈Ñ do wszystkich element√≥w z atrybutem data-tooltip
    document.addEventListener('mouseover', function(e) {
        if (e.target.closest('[data-tooltip]')) {
            const element = e.target.closest('[data-tooltip]');
            const tooltipContent = element.getAttribute('title');
            
            if (tooltipContent) {
                // Usuniƒôcie atrybutu title aby zapobiec domy≈õlnemu tooltipowi
                element.dataset.tooltipText = tooltipContent;
                element.removeAttribute('title');
                
                // Ustawienie zawarto≈õci tooltipa
                tooltip.innerHTML = tooltipContent;
                
                // Pozycjonowanie tooltipa
                const rect = element.getBoundingClientRect();
                const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
                
                tooltip.style.top = (rect.top + scrollTop - tooltip.offsetHeight - 10) + 'px';
                tooltip.style.left = (rect.left + rect.width/2 - tooltip.offsetWidth/2) + 'px';
                
                // Pokazanie tooltipa
                tooltip.style.opacity = '1';
                tooltip.style.visibility = 'visible';
            }
        }
    });

    document.addEventListener('mouseout', function(e) {
        if (e.target.closest('[data-tooltip]')) {
            const element = e.target.closest('[data-tooltip]');
            
            // Przywr√≥cenie atrybutu title
            if (element.dataset.tooltipText) {
                element.setAttribute('title', element.dataset.tooltipText);
                element.removeAttribute('data-tooltip-text');
            }
            
            // Ukrycie tooltipa
            tooltip.style.opacity = '0';
            tooltip.style.visibility = 'hidden';
        }
    });
}

        function loadTheme() {
            const savedTheme = localStorage.getItem(STORAGE_KEY_THEME);
            if (savedTheme === 'dark') {
                document.body.setAttribute('data-theme', 'dark');
            }
        }
        
        function loadRatings() {
            try {
                const savedRatings = localStorage.getItem(STORAGE_KEY_RATINGS);
                if (savedRatings) {
                    ratings = JSON.parse(savedRatings);
                }
            } catch (error) {
                console.error('Error loading ratings:', error);
                ratings = {};
            }
        }
        
        function loadBestAnswers() {
            try {
                const savedBestAnswers = localStorage.getItem(STORAGE_KEY_BEST_ANSWERS);
                if (savedBestAnswers) {
                    bestAnswers = JSON.parse(savedBestAnswers);
                }
            } catch (error) {
                console.error('Error loading best answers:', error);
                bestAnswers = {};
            }
        }
        
        function loadViewMode() {
            try {
                const savedViewMode = localStorage.getItem(STORAGE_KEY_VIEW_MODE);
                if (savedViewMode) {
                    setViewMode(savedViewMode);
                } else {
                    setViewMode('standard');
                }
            } catch (error) {
                console.error('Error loading view mode:', error);
                setViewMode('standard');
            }
        }
        
        function setViewMode(viewMode) {
            currentViewMode = viewMode;
            localStorage.setItem(STORAGE_KEY_VIEW_MODE, viewMode);
            
            // Update active button
            viewModeButtons.forEach(button => {
                if (button.getAttribute('data-view') === viewMode) {
                    button.classList.add('active');
                } else {
                    button.classList.remove('active');
                }
            });
            
            // Show/hide appropriate view
            if (viewMode === 'standard') {
                chatMessages.style.display = 'block';
                comparisonContainer.style.display = 'none';
            } else {
                chatMessages.style.display = 'none';
                comparisonContainer.style.display = 'flex';
                renderComparisonView();
            }
        }

        function toggleTheme() {
            const currentTheme = document.body.getAttribute('data-theme');
            if (currentTheme === 'dark') {
                document.body.removeAttribute('data-theme');
                localStorage.setItem(STORAGE_KEY_THEME, 'light');
            } else {
                document.body.setAttribute('data-theme', 'dark');
                localStorage.setItem(STORAGE_KEY_THEME, 'dark');
            }
        }

        function loadApiKey() {
            const savedApiKey = localStorage.getItem(STORAGE_KEY_API);
            if (savedApiKey) {
                apiKeyInput.value = savedApiKey;
                apiKey = savedApiKey;
                apiStatus.textContent = '‚úì Klucz zapisany';
                apiStatus.style.color = 'green';
                
                // Poka≈º przycisk testu po≈ÇƒÖczenia
                testConnectionButton.style.display = 'block';
                
                // Spr√≥bujmy pobraƒá modele u≈ºywajƒÖc preferowanego endpointu je≈õli istnieje
                const preferredEndpoint = localStorage.getItem('preferred_endpoint');
                if (preferredEndpoint) {
                    fetchModels(preferredEndpoint);
                } else {
                    // Je≈õli nie ma preferowanego endpointu, spr√≥buj pierwszego z listy
                    fetchModels(API_ENDPOINTS[0]);
                }
            }
        }

        function loadSelectedModels() {
            try {
                const savedSelectedModels = localStorage.getItem(STORAGE_KEY_SELECTED_MODELS);
                if (savedSelectedModels) {
                    selectedModels = JSON.parse(savedSelectedModels);
                }
            } catch (error) {
                console.error('Error loading selected models:', error);
                selectedModels = [];
            }
        }

        function loadConversationHistory() {
            try {
                const savedHistory = localStorage.getItem(STORAGE_KEY_HISTORY);
                if (savedHistory) {
                    conversationHistory = JSON.parse(savedHistory);
                    renderCurrentView();
                } else {
                    // Tylko je≈õli nie ma zapisanej historii, pokazujemy wiadomo≈õƒá powitalnƒÖ
                    chatMessages.innerHTML = `
                        <div class="message model-message">
                            <div class="message-header">Asystent</div>
                            <div class="message-content markdown-content">
                                Witaj w Chat SS! Aby rozpoczƒÖƒá, wprowad≈∫ sw√≥j klucz API OpenRouter i wybierz model z listy po lewej stronie.
                                
                                **Nowe funkcje:**
                                - Formatowanie tekstu u≈ºywajƒÖc **Markdown**
                                - Mo≈ºliwo≈õƒá przesy≈Çania plik√≥w do analizy
                                - Por√≥wnywanie odpowiedzi r√≥≈ºnych modeli
                                
                                Wypr√≥buj piszƒÖc tekst z formatowaniem Markdown!
                            </div>
                        </div>
                    `;
                    
                    // Process markdown in the welcome message
                    const welcomeContent = document.querySelector('.markdown-content');
                    welcomeContent.innerHTML = marked.parse(welcomeContent.textContent);
                }
            } catch (error) {
                console.error('Error loading conversation history:', error);
                conversationHistory = [];
                // Poka≈º wiadomo≈õƒá powitalnƒÖ w przypadku b≈Çƒôdu
                chatMessages.innerHTML = `
                    <div class="message model-message">
                        <div class="message-header">Asystent</div>
                        <div class="message-content markdown-content">
                            Witaj w Chat SS! Aby rozpoczƒÖƒá, wprowad≈∫ sw√≥j klucz API OpenRouter i wybierz model z listy po lewej stronie.
                            
                            **Nowe funkcje:**
                            - Formatowanie tekstu u≈ºywajƒÖc **Markdown**
                            - Mo≈ºliwo≈õƒá przesy≈Çania plik√≥w do analizy
                            - Por√≥wnywanie odpowiedzi r√≥≈ºnych modeli
                            
                            Wypr√≥buj piszƒÖc tekst z formatowaniem Markdown!
                        </div>
                    </div>
                `;
                
                // Process markdown in the welcome message
                const welcomeContent = document.querySelector('.markdown-content');
                welcomeContent.innerHTML = marked.parse(welcomeContent.textContent);
            }
        }
        
        function renderCurrentView() {
            if (currentViewMode === 'standard') {
                renderConversationHistory();
            } else {
                renderComparisonView();
            }
        }

        function handleApiKeyChange() {
            // Upewnijmy siƒô, ≈ºe klucz API jest poprawnie przetworzony
            const newApiKey = apiKeyInput.value.trim();
            if (newApiKey && newApiKey !== apiKey) {
                console.log('Zapisujƒô nowy klucz API (poczƒÖtek):', newApiKey.substring(0, 4) + '...');
                apiKey = newApiKey;
                localStorage.setItem(STORAGE_KEY_API, apiKey);
                
                apiStatus.textContent = '‚è≥ Sprawdzanie...';
                apiStatus.style.color = 'orange';
                
                // Poka≈º przycisk testu po≈ÇƒÖczenia
                testConnectionButton.style.display = 'block';
                debugInfo.style.display = 'none';
                
                // Spr√≥bujmy pobraƒá modele u≈ºywajƒÖc preferowanego endpointu je≈õli istnieje
                const preferredEndpoint = localStorage.getItem('preferred_endpoint');
                if (preferredEndpoint) {
                    fetchModels(preferredEndpoint);
                } else {
                    // Je≈õli nie ma preferowanego endpointu, spr√≥buj pierwszego z listy
                    fetchModels(API_ENDPOINTS[0]);
                }
            } else if (!newApiKey) {
                apiKey = '';
                localStorage.removeItem(STORAGE_KEY_API);
                apiStatus.textContent = '‚ùå Brak klucza API';
                apiStatus.style.color = 'red';
                
                chatInput.disabled = true;
                sendButton.disabled = true;
                fileUploadInput.disabled = true;
                modelList.innerHTML = '<div class="model-item">Wprowad≈∫ klucz API, aby zobaczyƒá dostƒôpne modele.</div>';
                modelsLoading.style.display = 'none';
            }
        }

        async function fetchModels(endpoint) {
            if (!apiKey) return;
            
            // U≈ºyj preferowanego endpointu lub pierwszego z listy
            endpoint = endpoint || localStorage.getItem('preferred_endpoint') || API_ENDPOINTS[0];
            
            modelList.innerHTML = '';
            modelsLoading.style.display = 'inline-block';
            
            try {
                // Dodajmy informacjƒô debugujƒÖcƒÖ w konsoli
                console.log('Pr√≥ba pobrania modeli z API u≈ºywajƒÖc endpointu:', endpoint);
                
                // Endpoint dla modeli
                const modelsUrl = endpoint.includes('/auth/key') ? 
                    API_ENDPOINTS[0] + '/models' : // Je≈õli to endpoint auth, u≈ºyj g≈Ç√≥wnego URL dla modeli
                    `${endpoint}/models`;
                
                let mainResponse = null;
                
                try {
                    mainResponse = await fetch(modelsUrl, {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${apiKey.trim()}`,
                            'Referer': window.location.origin,
                            'X-Title': 'Chat SS',
                            'Content-Type': 'application/json'
                        },
                        credentials: 'omit',
                        mode: 'cors'
                    });
                    
                    // Logujemy status odpowiedzi dla cel√≥w diagnostycznych
                    console.log('Status odpowiedzi:', mainResponse.status, mainResponse.statusText);
                } catch (mainFetchError) {
                    console.error('B≈ÇƒÖd podczas pobierania z g≈Ç√≥wnego endpointu:', mainFetchError);
                }
                
                // Je≈õli g≈Ç√≥wny endpoint nie dzia≈Ça lub zwr√≥ci≈Ç b≈ÇƒÖd, spr√≥buj alternatywnych
                if (!mainResponse || !mainResponse.ok) {
                    let successResponse = null;
                    
                    // Je≈õli aktualny endpoint nie zadzia≈Ça≈Ç, spr√≥buj innych
                    for (const altEndpoint of API_ENDPOINTS) {
                        if (altEndpoint === endpoint) continue; // Pomi≈Ñ ju≈º sprawdzony endpoint
                        
                        try {
                            console.log('Pr√≥ba alternatywnego endpointu:', altEndpoint);
                            
                            // Endpoint dla modeli
                            const altModelsUrl = altEndpoint.includes('/auth/key') ? 
                                API_ENDPOINTS[0] + '/models' : // Je≈õli to endpoint auth, u≈ºyj g≈Ç√≥wnego URL dla modeli
                                `${altEndpoint}/models`;
                            
                            const altResponse = await fetch(altModelsUrl, {
                                method: 'GET',
                                headers: {
                                    'Authorization': `Bearer ${apiKey.trim()}`,
                                    'Referer': window.location.origin,
                                    'X-Title': 'Chat SS',
                                    'Content-Type': 'application/json'
                                },
                                credentials: 'omit',
                                mode: 'cors'
                            });
                            
                            console.log('Status alternatywnej odpowiedzi:', altResponse.status);
                            
                            if (altResponse.ok) {
                                // U≈ºyj alternatywnej odpowiedzi i zapisz dzia≈ÇajƒÖcy endpoint
                                successResponse = altResponse;
                                localStorage.setItem('preferred_endpoint', altEndpoint);
                                console.log('Znaleziono dzia≈ÇajƒÖcy endpoint:', altEndpoint);
                                break;
                            }
                        } catch (altError) {
                            console.error('B≈ÇƒÖd alternatywnego endpointu:', altError);
                        }
                    }
                    
                    if (successResponse) {
                        // U≈ºyj znalezionej dzia≈ÇajƒÖcej odpowiedzi
                        mainResponse = successResponse;
                    } else {
                        // Wszystkie pr√≥by zawiod≈Çy
                        throw new Error('Wszystkie pr√≥by po≈ÇƒÖczenia z API nieudane');
                    }
                } else {
                    // Zapisz dzia≈ÇajƒÖcy endpoint jako preferowany
                    localStorage.setItem('preferred_endpoint', endpoint);
                }
                
                // Przetw√≥rz odpowied≈∫ i zaktualizuj listƒô modeli
                const data = await mainResponse.json();
                // Sort models based on the order/ranking from OpenRouter
                // This assumes the API returns models in the preferred order
                models = data.data || [];
                
                // Sort models by their pricing - free models first, then by their position/ranking
                sortModels();
                
                renderModels();
                
                apiStatus.textContent = '‚úì Klucz poprawny';
                apiStatus.style.color = 'green';
                
                chatInput.disabled = false;
                sendButton.disabled = false;
                fileUploadInput.disabled = false;
                
            } catch (error) {
                console.error('Error fetching models:', error);
                
                // Pr√≥bujmy wydobyƒá wiƒôcej informacji o b≈Çƒôdzie
                let errorDetails = '';
                try {
                    if (mainResponse && !mainResponse.ok) {
                        const errorData = await mainResponse.text();
                        errorDetails = ` (${errorData})`;
                        console.log('Szczeg√≥≈Çy b≈Çƒôdu:', errorData);
                    }
                } catch (e) {
                    console.error('Nie mo≈ºna odczytaƒá szczeg√≥≈Ç√≥w b≈Çƒôdu:', e);
                }
                
                apiStatus.textContent = `‚ùå Problem z API: ${error.message}${errorDetails}`;
                apiStatus.style.color = 'red';
                
                modelList.innerHTML = `<div class="model-item">
                    <div>Nie uda≈Ço siƒô pobraƒá modeli. Sprawd≈∫ sw√≥j klucz API.</div>
                    <div style="font-size: 11px; margin-top: 8px;">B≈ÇƒÖd: ${error.message}</div>
                    <div style="font-size: 11px; margin-top: 4px;">
                        Upewnij siƒô, ≈ºe format klucza API jest poprawny i nie zawiera dodatkowych znak√≥w (np. spacji).
                    </div>
                </div>`;
                
                chatInput.disabled = true;
                sendButton.disabled = true;
                fileUploadInput.disabled = true;
            } finally {
                modelsLoading.style.display = 'none';
            }
        }
        
        // Model mo≈ºe zwr√≥ciƒá b≈Çƒôdne ceny, wiƒôc dodajmy dodatkowe zabezpieczenie
        function isModelFree(model) {
            // Check if the model has pricing info and if it's free
            if (!model || !model.pricing) return false;
            
            try {
                // Some models may use null instead of 0 for free tiers, check both
                const promptFree = model.pricing.prompt === 0 || model.pricing.prompt === null;
                const completionFree = model.pricing.completion === 0 || model.pricing.completion === null;
                
                return promptFree && completionFree;
            } catch (e) {
                console.error('B≈ÇƒÖd sprawdzania czy model jest darmowy:', e);
                return false;
            }
        }
// Formatowanie ceny do wy≈õwietlenia
function formatPrice(price) {
    if (price === 0 || price === null) return 'ZA DARMO';
    if (typeof price === 'number') {
        return `${price.toFixed(4)}`;
    }
    return 'N/A';
}
 function renderModels() {
    modelList.innerHTML = '';
    
    if (models.length === 0) {
        modelList.innerHTML = '<div class="model-item">Brak dostƒôpnych modeli.</div>';
        return;
    }
    
    // Dodaj modal do dokumentu, je≈õli jeszcze nie istnieje
    if (!document.getElementById('model-details-modal')) {
        const modalContainer = document.createElement('div');
        modalContainer.innerHTML = `
        <div id="model-details-modal" class="modal">
            <div class="modal-content">
                <span class="modal-close">&times;</span>
                <div class="modal-header" id="modal-model-name">Szczeg√≥≈Çy modelu</div>
                <div class="modal-details" id="modal-model-details">
                    <!-- Szczeg√≥≈Çy modelu bƒôdƒÖ dynamicznie wstawiane tutaj -->
                </div>
            </div>
        </div>
        `;
        document.body.appendChild(modalContainer.firstElementChild);
        
        // Inicjalizacja obs≈Çugi modala
        const modal = document.getElementById('model-details-modal');
        const modalContent = modal.querySelector('.modal-content');
        const closeButton = modal.querySelector('.modal-close');
        
        // Funkcja zamykajƒÖca modal
        function closeModal() {
            modal.style.display = 'none';
        }
        
        // Zatrzymaj propagacjƒô klikniƒôƒá wewnƒÖtrz tre≈õci modala
        modalContent.addEventListener('click', (e) => {
            e.stopPropagation();
        });
        
        // Zamykanie modala po klikniƒôciu poza jego obszarem
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal();
            }
        });
        
        // Zamykanie modala przez przycisk zamkniƒôcia
        closeButton.addEventListener('click', closeModal);
        
        // Zamykanie modala klawiszem Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.style.display === 'flex') {
                closeModal();
            }
        });
    }
    
    models.forEach(model => {
        try {
            const isSelected = selectedModels.includes(model.id);
            const isFree = isModelFree(model);
            
            // Tworzenie elementu listy modeli z uproszczonym wyglƒÖdem
            const modelElement = document.createElement('div');
            modelElement.className = `model-item ${isSelected ? 'selected' : ''} ${isFree ? 'free' : ''}`;
            modelElement.dataset.modelId = model.id;
            
            // Tworzenie uproszczonej zawarto≈õci - nazwa modelu i ikona informacyjna
            let modelHTML = `
                <div class="model-name">${model.name || model.id}</div>
            `;
            
            // Dodanie oznaczenia "Za darmo" je≈õli model jest darmowy
            if (isFree) {
                modelHTML += `<div class="free-badge">ZA DARMO</div>`;
            }
            
            // Dodanie ikony informacyjnej
            modelHTML += `<span class="info-icon" data-tooltip="${model.description || 'Brak opisu'}">‚ÑπÔ∏è</span>`;
            
            // Dodanie ukrytego checkboxa do zaznaczania
            const checkboxContainer = document.createElement('label');
            checkboxContainer.className = 'checkbox-container';
            checkboxContainer.style.margin = '0';
            checkboxContainer.style.padding = '0';
            checkboxContainer.style.display = 'inline-flex';
            checkboxContainer.textContent = '';
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.checked = isSelected;
            checkbox.addEventListener('change', () => toggleModelSelection(model.id));
            
            const checkmark = document.createElement('span');
            checkmark.className = 'checkmark';
            checkmark.style.marginLeft = 'auto';
            
            checkboxContainer.appendChild(checkbox);
            checkboxContainer.appendChild(checkmark);
            
            modelElement.innerHTML = modelHTML;
            modelElement.appendChild(checkboxContainer);
            
            modelElement.addEventListener('click', (e) => {
                if (!e.target.closest('.checkbox-container, .info-icon')) {
                    toggleModelSelection(model.id);
                }
            });
            
            // Dodaj event listener do ikony informacyjnej
            const infoIcon = modelElement.querySelector('.info-icon');
            infoIcon.addEventListener('click', (e) => {
                e.stopPropagation();
                showModelDetails(model.id);
            });
            
            modelList.appendChild(modelElement);
        } catch (modelError) {
            console.error('B≈ÇƒÖd renderowania modelu:', modelError, model);
            // Dodanie uproszczonego elementu b≈Çƒôdu
            const errorModelElement = document.createElement('div');
            errorModelElement.className = 'model-item';
            errorModelElement.innerHTML = `
                <div class="model-name">${model.id || 'Model bez ID'}</div>
                <div class="model-description">B≈ÇƒÖd</div>
            `;
            modelList.appendChild(errorModelElement);
        }
    });
    
    // Globalna funkcja do wy≈õwietlania szczeg√≥≈Ç√≥w modelu
    window.showModelDetails = (modelId) => {
        const model = models.find(m => m.id === modelId);
        if (!model) return;
        
        const modal = document.getElementById('model-details-modal');
        const modelName = document.getElementById('modal-model-name');
        const modelDetails = document.getElementById('modal-model-details');
        
        // Ustaw nazwƒô modelu
        modelName.textContent = model.name || modelId;
        
        // Przygotuj szczeg√≥≈Çy modelu
        let detailsHTML = '';
        
        // Opis
        if (model.description) {
            detailsHTML += `
                <div class="modal-detail">
                    <strong>Opis</strong>
                    <p>${model.description}</p>
                </div>
            `;
        }
        
        // Kontekst i tokeny
        detailsHTML += `
            <div class="modal-detail">
                <strong>D≈Çugo≈õƒá kontekstu</strong>
                <p>${model.context_length || 'Nieznana'} token√≥w</p>
            </div>
        `;
        
        // Szybko≈õƒá token√≥w
        if (model.token_rate?.tokens_per_second) {
            detailsHTML += `
                <div class="modal-detail">
                    <strong>Szybko≈õƒá generowania</strong>
                    <p>${model.token_rate.tokens_per_second.toFixed(1)} token√≥w/sekundƒô</p>
                </div>
            `;
        }
        
        // Cennik
        if (model.pricing) {
            try {
                let promptPrice = formatPrice(model.pricing.prompt);
                let completionPrice = formatPrice(model.pricing.completion);
                
                detailsHTML += `
                    <div class="modal-detail">
                        <strong>Cennik</strong>
                        <p>Input: ${promptPrice} / Output: ${completionPrice} (USD)</p>
                    </div>
                `;
            } catch (priceError) {
                console.error('B≈ÇƒÖd formatowania ceny:', priceError);
            }
        }
        
        // Dodatkowe opcje je≈õli sƒÖ dostƒôpne
        if (model.extra_details) {
            detailsHTML += `
                <div class="modal-detail">
                    <strong>Dodatkowe informacje</strong>
                    <p>${JSON.stringify(model.extra_details)}</p>
                </div>
            `;
        }
        
        modelDetails.innerHTML = detailsHTML;
        
        // Poka≈º modal
        modal.style.display = 'flex';
    }
}

// Formatowanie ceny do wy≈õwietlenia
function formatPrice(price) {
    if (price === 0 || price === null) return 'ZA DARMO';
    if (typeof price === 'number') {
        return `${price.toFixed(4)}`;
    }
    return 'N/A';
}

// Model mo≈ºe zwr√≥ciƒá b≈Çƒôdne ceny, wiƒôc dodajmy dodatkowe zabezpieczenie
function isModelFree(model) {
    // Check if the model has pricing info and if it's free
    if (!model || !model.pricing) return false;
    
    try {
        // Some models may use null instead of 0 for free tiers, check both
        const promptFree = model.pricing.prompt === 0 || model.pricing.prompt === null;
        const completionFree = model.pricing.completion === 0 || model.pricing.completion === null;
        
        return promptFree && completionFree;
    } catch (e) {
        console.error('B≈ÇƒÖd sprawdzania czy model jest darmowy:', e);
        return false;
    }
}
function initializeModalHandling() {
    const modal = document.getElementById('model-details-modal');
    const modalContent = modal.querySelector('.modal-content');
    const closeButton = modal.querySelector('.modal-close');
    
    // Funkcja zamykajƒÖca modal
    function closeModal() {
        modal.style.display = 'none';
    }
    
    // Zatrzymaj propagacjƒô klikniƒôƒá wewnƒÖtrz tre≈õci modala
    modalContent.addEventListener('click', (e) => {
        e.stopPropagation();
    });
    
    // Zamykanie modala po klikniƒôciu poza jego obszarem
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal();
        }
    });
    
    // Zamykanie modala przez przycisk zamkniƒôcia
    closeButton.addEventListener('click', (e) => {
        e.stopPropagation(); // Dodane, aby uniknƒÖƒá przypadkowego wyzwalania innych zdarze≈Ñ
        closeModal();
    });
    
    // Zamykanie modala klawiszem Escape
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
            closeModal();
        }
    });
}

// Wywo≈Çaj funkcjƒô inicjalizacji modala
document.addEventListener('DOMContentLoaded', initializeModalHandling);
        function toggleModelSelection(modelId) {
            const index = selectedModels.indexOf(modelId);
            
            if (index === -1) {
                selectedModels.push(modelId);
            } else {
                selectedModels.splice(index, 1);
            }
            
            localStorage.setItem(STORAGE_KEY_SELECTED_MODELS, JSON.stringify(selectedModels));
            renderModels();
            
            // Enable/disable chat based on selection
            const hasSelectedModels = selectedModels.length > 0;
            chatInput.disabled = !hasSelectedModels || !apiKey;
            sendButton.disabled = !hasSelectedModels || !apiKey;
            fileUploadInput.disabled = !hasSelectedModels || !apiKey;
        }

        function renderConversationHistory() {
    // Czy≈õcimy okno chatu przed renderowaniem
    chatMessages.innerHTML = '';
    
    if (conversationHistory.length === 0) {
        chatMessages.innerHTML = `
            <div class="message model-message">
                <div class="message-header">Asystent</div>
                <div class="message-content markdown-content">
                    Witaj w Chat SS! Aby rozpoczƒÖƒá, wprowad≈∫ sw√≥j klucz API OpenRouter i wybierz model z listy po lewej stronie.
                    
                    **Nowe funkcje:**
                    - Formatowanie tekstu u≈ºywajƒÖc **Markdown**
                    - Mo≈ºliwo≈õƒá przesy≈Çania plik√≥w do analizy
                    - Por√≥wnywanie odpowiedzi r√≥≈ºnych modeli
                    
                    Wypr√≥buj piszƒÖc tekst z formatowaniem Markdown!
                </div>
            </div>
        `;
        
        // Process markdown in the welcome message
        const welcomeContent = document.querySelector('.markdown-content');
        welcomeContent.innerHTML = marked.parse(welcomeContent.textContent);
        return;
    }
    
    let lastQueryId = null;
    
    conversationHistory.forEach((message, index) => {
        const messageElement = document.createElement('div');
        messageElement.className = `message ${message.role === 'user' ? 'user-message' : 'model-message'}`;
        
        // Use existing message ID if available, otherwise generate a new one
        const messageId = message.id || `msg-${index}-${Date.now()}`;
        messageElement.dataset.messageId = messageId;
        
        // For user messages, create a query ID that will group the subsequent model responses
        if (message.role === 'user') {
            lastQueryId = `query-${index}-${Date.now()}`;
            messageElement.dataset.queryId = lastQueryId;
        } else if (lastQueryId) {
            // For model responses, associate them with the last user query
            messageElement.dataset.queryId = lastQueryId;
            
            // Check if this message is marked as best answer
            if (bestAnswers[lastQueryId] === messageId) {
                messageElement.classList.add('best-answer');
            }
        }
        
        const messageHeader = document.createElement('div');
        messageHeader.className = 'message-header';
        messageHeader.textContent = message.role === 'user' ? 'Ty' : 'Asystent';
        
        const messageContent = document.createElement('div');
        messageContent.className = 'message-content markdown-content';
        
        // Set the raw text content first
        messageContent.textContent = message.content;
        
        // Then replace with rendered markdown
        messageContent.innerHTML = marked.parse(message.content);
        
        // Apply syntax highlighting to code blocks
        messageContent.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightElement(block);
        });
        
        messageElement.appendChild(messageHeader);
        messageElement.appendChild(messageContent);
        
        // Add files if message has them
        if (message.files && message.files.length > 0) {
            const filesContainer = document.createElement('div');
            filesContainer.className = 'message-files';
            
            message.files.forEach(file => {
                const fileElement = document.createElement('div');
                fileElement.className = 'message-file';
                
                const fileThumbnail = document.createElement('div');
                fileThumbnail.className = 'message-file-thumbnail';
                
                // Different representation based on file type
                if (file.type.startsWith('image/')) {
                    // For images, show thumbnail
                    const img = document.createElement('img');
                    img.src = file.dataUrl;
                    img.alt = file.name;
                    fileThumbnail.appendChild(img);
                } else {
                    // For other files, show icon based on type
                    const icon = document.createElement('div');
                    icon.className = 'message-file-icon';
                    
                    // Choose icon based on file type
                    if (file.type === 'application/pdf') {
                        icon.textContent = 'üìÑ';
                    } else if (file.type.includes('spreadsheet') || file.type.includes('csv')) {
                        icon.textContent = 'üìä';
                    } else if (file.type.includes('document')) {
                        icon.textContent = 'üìù';
                    } else if (file.type.includes('presentation')) {
                        icon.textContent = 'üì∫';
                    } else {
                        icon.textContent = 'üìÅ';
                    }
                    
                    fileThumbnail.appendChild(icon);
                }
                
                const fileName = document.createElement('div');
                fileName.className = 'message-file-name';
                fileName.textContent = file.name;
                
                fileElement.appendChild(fileThumbnail);
                fileElement.appendChild(fileName);
                
                // Click on file to download/view it
                fileElement.addEventListener('click', () => {
                    // Create a download link for the file
                    const link = document.createElement('a');
                    link.href = file.dataUrl;
                    link.download = file.name;
                    link.target = '_blank';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                });
                
                filesContainer.appendChild(fileElement);
            });
            
            messageElement.appendChild(filesContainer);
        }
        
        if (message.model) {
            const footerContainer = document.createElement('div');
            footerContainer.className = 'model-response-footer';
            
            // Model label
            const modelLabel = document.createElement('div');
            modelLabel.className = 'model-label';
            modelLabel.textContent = `Model: ${message.model}`;
            
            // Rating stars
            const ratingContainer = document.createElement('div');
            ratingContainer.className = 'rating-stars';
            
            // Create 5 stars
            for (let i = 1; i <= 5; i++) {
                const star = document.createElement('span');
                star.className = 'star';
                star.textContent = '‚òÖ';
                star.dataset.rating = i;
                
                // Check if this message has a rating
                if (ratings[messageId] && ratings[messageId] >= i) {
                    star.classList.add('active');
                }
                
                star.addEventListener('click', () => {
                    // Update the rating
                    setRating(messageId, i);
                    
                    // Update the UI
                    ratingContainer.querySelectorAll('.star').forEach((s, idx) => {
                        if (idx < i) {
                            s.classList.add('active');
                        } else {
                            s.classList.remove('active');
                        }
                    });
                });
                
                ratingContainer.appendChild(star);
            }
            
            // Best answer button
            const bestAnswerBtn = document.createElement('button');
            bestAnswerBtn.className = 'best-answer-button';
            bestAnswerBtn.textContent = 'Najlepsza odpowied≈∫';
            
            // Check if this message is already marked as best answer
            if (bestAnswers[lastQueryId] === messageId) {
                bestAnswerBtn.classList.add('marked');
                messageElement.classList.add('best-answer');
            }
            
            bestAnswerBtn.addEventListener('click', () => {
                // Toggle best answer
                toggleBestAnswer(lastQueryId, messageId);
                
                // Update the UI
                const isBest = bestAnswers[lastQueryId] === messageId;
                if (isBest) {
                    bestAnswerBtn.classList.add('marked');
                    messageElement.classList.add('best-answer');
                } else {
                    bestAnswerBtn.classList.remove('marked');
                    messageElement.classList.remove('best-answer');
                }
                
                // Update other messages for this query
                document.querySelectorAll(`[data-query-id="${lastQueryId}"]`).forEach(el => {
                    if (el.dataset.messageId !== messageId) {
                        if (isBest) {
                            el.classList.remove('best-answer');
                            el.querySelector('.best-answer-button')?.classList.remove('marked');
                        }
                    }
                });
            });
            
            footerContainer.appendChild(modelLabel);
            footerContainer.appendChild(ratingContainer);
            footerContainer.appendChild(bestAnswerBtn);
            
            messageElement.appendChild(footerContainer);
        }
        
        chatMessages.appendChild(messageElement);
    });
    
    // Scroll to bottom
    chatMessages.scrollTop = chatMessages.scrollHeight;
}
        
       function renderComparisonView() {
    comparisonContainer.innerHTML = '';
    
    if (conversationHistory.length === 0) {
        comparisonContainer.innerHTML = `
            <div style="padding: 20px; text-align: center;">
                <p>Brak historii konwersacji do por√≥wnania.</p>
                <p>Zadaj pytanie, aby zobaczyƒá odpowiedzi modeli obok siebie.</p>
            </div>
        `;
        return;
    }
    
    // Group messages by query and model
    const groupedMessages = groupMessagesByQuery();
    
    // Get the last user query
    const lastQueryId = Object.keys(groupedMessages).pop();
    
    if (!lastQueryId) return;
    
    const queryGroup = groupedMessages[lastQueryId];
    
    // Create a main flex container with column direction
    const mainContainer = document.createElement('div');
    mainContainer.style.display = 'flex';
    mainContainer.style.flexDirection = 'column';
    mainContainer.style.width = '100%';
    
    // Create user query element
    const userQueryElement = document.createElement('div');
    userQueryElement.className = 'user-query';
    userQueryElement.innerHTML = `
        <div class="query-header">Twoje pytanie:</div>
        <div class="markdown-content">${marked.parse(queryGroup.userMessage.content)}</div>
    `;
    
    // Create a container for the user query that spans the full width
    const userQueryContainer = document.createElement('div');
    userQueryContainer.style.width = '100%';
    userQueryContainer.style.marginBottom = '20px';
    userQueryContainer.appendChild(userQueryElement);
    
    mainContainer.appendChild(userQueryContainer);
    
    // Dodaj kontener do przycisku zatrzymania, je≈õli aktywne strumieniowanie
    if (isStreaming) {
        const streamingControlsContainer = document.createElement('div');
        streamingControlsContainer.style.width = '100%';
        streamingControlsContainer.style.marginBottom = '20px';
        
        const stopButton = document.createElement('button');
        stopButton.className = 'send-button';
        stopButton.style.backgroundColor = '#f44336';
        stopButton.textContent = 'Zatrzymaj generowanie';
        stopButton.addEventListener('click', () => {
            if (streamController) {
                streamController.abort();
                stopButton.textContent = 'Generowanie zatrzymane';
                stopButton.disabled = true;
                setTimeout(() => {
                    streamingControlsContainer.remove();
                }, 2000);
            }
        });
        
        streamingControlsContainer.appendChild(stopButton);
        mainContainer.appendChild(streamingControlsContainer);
    }
    
    // Create a wrapper for model responses
    const responsesWrapper = document.createElement('div');
    responsesWrapper.style.display = 'flex';
    responsesWrapper.style.width = '100%';
    responsesWrapper.style.overflowX = 'auto';
    
    // Add a column for each model response
    Object.keys(queryGroup.modelResponses).forEach(modelName => {
        const response = queryGroup.modelResponses[modelName];
        const messageId = response.messageId;
        
        const column = document.createElement('div');
        column.className = 'comparison-column';
        column.dataset.messageId = messageId;
        column.dataset.queryId = lastQueryId;
        
        // Check if this is the best answer
        const isBestAnswer = bestAnswers[lastQueryId] === messageId;
        if (isBestAnswer) {
            column.classList.add('best-answer');
        }
        
        const header = document.createElement('div');
        header.className = 'comparison-column-header';
        header.innerHTML = `
            <div>${modelName}</div>
            ${isBestAnswer ? '<div class="best-answer-badge">Najlepsza odpowied≈∫</div>' : ''}
        `;
        
        const content = document.createElement('div');
        content.className = 'comparison-content markdown-content';
        content.innerHTML = marked.parse(response.content);
        
        // Apply syntax highlighting to code blocks
        content.querySelectorAll('pre code').forEach((block) => {
            hljs.highlightElement(block);
        });
        
        const footer = document.createElement('div');
        footer.className = 'model-response-footer';
        
        // Rating stars
        const ratingContainer = document.createElement('div');
        ratingContainer.className = 'rating-stars';
        
        // Create 5 stars
        for (let i = 1; i <= 5; i++) {
            const star = document.createElement('span');
            star.className = 'star';
            star.textContent = '‚òÖ';
            star.dataset.rating = i;
            
            // Check if this message has a rating
            if (ratings[messageId] && ratings[messageId] >= i) {
                star.classList.add('active');
            }
            
            star.addEventListener('click', () => {
                // Update the rating
                setRating(messageId, i);
                
                // Update the UI
                ratingContainer.querySelectorAll('.star').forEach((s, idx) => {
                    if (idx < i) {
                        s.classList.add('active');
                    } else {
                        s.classList.remove('active');
                    }
                });
            });
            
            ratingContainer.appendChild(star);
        }
        
        // Best answer button
        const bestAnswerBtn = document.createElement('button');
        bestAnswerBtn.className = 'best-answer-button';
        bestAnswerBtn.textContent = 'Najlepsza odpowied≈∫';
        
        if (isBestAnswer) {
            bestAnswerBtn.classList.add('marked');
        }
        
        bestAnswerBtn.addEventListener('click', () => {
            // Toggle best answer
            toggleBestAnswer(lastQueryId, messageId);
            
            // Update the UI for all columns
            document.querySelectorAll(`.comparison-column[data-query-id="${lastQueryId}"]`).forEach(col => {
                const colMessageId = col.dataset.messageId;
                const isBest = bestAnswers[lastQueryId] === colMessageId;
                
                // Update this column
                if (isBest) {
                    col.classList.add('best-answer');
                    col.querySelector('.best-answer-button').classList.add('marked');
                    col.querySelector('.comparison-column-header').innerHTML = `
                        <div>${col.querySelector('.comparison-column-header div').textContent}</div>
                        <div class="best-answer-badge">Najlepsza odpowied≈∫</div>
                    `;
                } else {
                    col.classList.remove('best-answer');
                    col.querySelector('.best-answer-button').classList.remove('marked');
                    col.querySelector('.comparison-column-header').innerHTML = `
                        <div>${col.querySelector('.comparison-column-header div').textContent}</div>
                    `;
                }
            });
        });
        
        footer.appendChild(ratingContainer);
        footer.appendChild(bestAnswerBtn);
        
        column.appendChild(header);
        column.appendChild(content);
        column.appendChild(footer);
        
        responsesWrapper.appendChild(column);
    });
    
    // Append the responses wrapper to the main container
    mainContainer.appendChild(responsesWrapper);
    
    // Finally, append the main container to the comparison container
    comparisonContainer.appendChild(mainContainer);
}
        
        function groupMessagesByQuery() {
            const groups = {};
            let currentQueryId = null;
            let currentUserMessage = null;
            
            conversationHistory.forEach((message, index) => {
                if (message.role === 'user') {
                    // Create a new query group
                    currentQueryId = `query-${index}-${Date.now()}`;
                    currentUserMessage = message;
                    
                    groups[currentQueryId] = {
                        userMessage: message,
                        modelResponses: {}
                    };
                } else if (message.role === 'assistant' && currentQueryId) {
                    // Add model response to the current query group
                    const messageId = `msg-${index}-${Date.now()}`;
                    
                    groups[currentQueryId].modelResponses[message.model] = {
                        content: message.content,
                        model: message.model,
                        messageId: messageId
                    };
                }
            });
            
            return groups;
        }
        
        function setRating(messageId, rating) {
            ratings[messageId] = rating;
            localStorage.setItem(STORAGE_KEY_RATINGS, JSON.stringify(ratings));
        }
        
        function toggleBestAnswer(queryId, messageId) {
            if (bestAnswers[queryId] === messageId) {
                // If already marked as best, remove the mark
                delete bestAnswers[queryId];
            } else {
                // Otherwise, mark as best
                bestAnswers[queryId] = messageId;
            }
            
            localStorage.setItem(STORAGE_KEY_BEST_ANSWERS, JSON.stringify(bestAnswers));
        }

        // File handling functions
        function handleFileUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                // Check file size
                if (file.size > MAX_FILE_SIZE) {
                    alert(`Plik "${file.name}" jest zbyt du≈ºy. Maksymalny rozmiar to 10MB.`);
                    continue;
                }
                
                // Read file as data URL
                const reader = new FileReader();
                reader.onload = (e) => {
                    const fileData = {
                        name: file.name,
                        type: file.type,
                        size: file.size,
                        dataUrl: e.target.result
                    };
                    
                    uploadedFiles.push(fileData);
                    renderFileList();
                };
                
                reader.onerror = () => {
                    alert(`B≈ÇƒÖd podczas odczytu pliku "${file.name}".`);
                };
                
                reader.readAsDataURL(file);
            }
            
            // Reset the input value to allow uploading the same file again
            event.target.value = '';
        }

        function renderFileList() {
            fileList.innerHTML = '';
            
            if (uploadedFiles.length === 0) {
                fileUploadInfo.textContent = '';
                return;
            }
            
            fileUploadInfo.textContent = `Dodano ${uploadedFiles.length} ${uploadedFiles.length === 1 ? 'plik' : 'pliki'}`;
            
            uploadedFiles.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                
                const fileThumbnail = document.createElement('div');
                fileThumbnail.className = 'file-thumbnail';
                
                // Different representation based on file type
                if (file.type.startsWith('image/')) {
                    // For images, show thumbnail
                    const img = document.createElement('img');
                    img.src = file.dataUrl;
                    img.alt = file.name;
                    fileThumbnail.appendChild(img);
                } else {
                    // For other files, show icon based on type
                    const icon = document.createElement('div');
                    icon.className = 'file-icon';
                    
                    // Choose icon based on file type
                    if (file.type === 'application/pdf') {
                        icon.textContent = 'üìÑ';
                    } else if (file.type.includes('spreadsheet') || file.type.includes('csv')) {
                        icon.textContent = 'üìä';
                    } else if (file.type.includes('document')) {
                        icon.textContent = 'üìù';
                    } else if (file.type.includes('presentation')) {
                        icon.textContent = 'üì∫';
                    } else {
                        icon.textContent = 'üìÅ';
                    }
                    
                    fileThumbnail.appendChild(icon);
                }
                
                const fileName = document.createElement('div');
                fileName.className = 'file-name';
                fileName.textContent = file.name;
                
                const removeButton = document.createElement('div');
                removeButton.className = 'file-remove';
                removeButton.textContent = '√ó';
                removeButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    uploadedFiles.splice(index, 1);
                    renderFileList();
                });
                
                fileItem.appendChild(fileThumbnail);
                fileItem.appendChild(fileName);
                fileItem.appendChild(removeButton);
                
                fileList.appendChild(fileItem);
            });
        }

        async function sendMessage() {
    const messageText = chatInput.value.trim();
    if ((!messageText && uploadedFiles.length === 0) || isLoading || selectedModels.length === 0) return;
    
    // Disable input and button while sending
    isLoading = true;
    chatInput.disabled = true;
    sendButton.disabled = true;
    fileUploadInput.disabled = true;
    typingIndicator.style.display = 'inline-block';
    
    // Add user message to conversation history
    const userMessage = {
        role: 'user',
        content: messageText,
        files: [...uploadedFiles] // Add uploaded files to the message
    };
    
    conversationHistory.push(userMessage);
    
    // Clear input and file list
    chatInput.value = '';
    chatInput.style.height = 'auto';
    uploadedFiles = [];
    renderFileList();
    
    // Render the user message immediately
    renderCurrentView();
    
    // Create stop generation button and progress indicator
    createStopGenerationButton();
    
    // If multiple models are selected, send requests to all of them
    const modelPromises = selectedModels.map(modelId => sendMessageToModel(messageText, modelId));
    
    try {
        await Promise.all(modelPromises);
        // After all responses are received, clean up
        removeStopGenerationButton();
    } catch (error) {
        console.error('Error sending messages:', error);
        // Add error message to conversation
        conversationHistory.push({
            role: 'assistant',
            content: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas komunikacji z modelem. Spr√≥buj ponownie lub sprawd≈∫ sw√≥j klucz API.',
            model: 'System'
        });
        renderCurrentView();
        removeStopGenerationButton();
    } finally {
        // Re-enable input and button
        isLoading = false;
        chatInput.disabled = false;
        sendButton.disabled = false;
        fileUploadInput.disabled = false;
        typingIndicator.style.display = 'none';
        chatInput.focus();
    }
}

      async function sendMessageToModel(messageText, modelId) {
    try {
        // Prepare the conversation history for this model
        const modelMessages = conversationHistory
            .filter(msg => !msg.model || msg.model === modelId) // Filter only relevant messages for this model
            .map(msg => {
                // Basic message structure
                const formattedMsg = {
                    role: msg.role,
                    content: msg.content
                };
                
                // If this is the current message and has files, add file information
                if (msg.files && msg.files.length > 0) {
                    // Add file descriptions to the message content
                    let fileDescriptions = "\n\n**Do≈ÇƒÖczone pliki:**\n";
                    msg.files.forEach(file => {
                        fileDescriptions += `- ${file.name} (${formatFileSize(file.size)}, typ: ${file.type})\n`;
                    });
                    
                    // Append file descriptions to content
                    formattedMsg.content += fileDescriptions;
                }
                
                return formattedMsg;
            });
        
        // Add the current message if it's not already included
        if (!modelMessages.some(msg => msg.role === 'user' && msg.content === messageText)) {
            modelMessages.push({
                role: 'user',
                content: messageText
            });
        }
        
        // U≈ºyj preferowanego endpointu je≈õli istnieje
        const preferredEndpoint = localStorage.getItem('preferred_endpoint');
        const endpoint = preferredEndpoint || API_ENDPOINTS[0];
        
        // Endpoint dla chat completions
        const chatUrl = endpoint.includes('/auth/key') ? 
            API_ENDPOINTS[0] + '/chat/completions' : // Je≈õli to endpoint auth, u≈ºyj g≈Ç√≥wnego URL
            `${endpoint}/chat/completions`;
        
        console.log('Wysy≈Çanie wiadomo≈õci do API URL:', chatUrl);
        
        // Przygotuj kontroler do anulowania strumieniowania
        streamController = new AbortController();
        isStreaming = true;
        
        // Find the model name for display
        const modelInfo = models.find(m => m.id === modelId);
        const modelName = modelInfo ? (modelInfo.name || modelId) : modelId;
        
        // Generate a unique and consistent message ID
        const messageId = `streaming-${Date.now()}-${modelId}`;
        
        // Dodaj nowƒÖ pustƒÖ wiadomo≈õƒá do historii
        const responseMessage = {
            role: 'assistant',
            content: '',
            model: modelName,
            id: messageId
        };
        
        conversationHistory.push(responseMessage);
        renderCurrentView();
        
        // Find the streaming message element after rendering
        let streamingMessageElement;
        let contentElement = null;
        
        // For standard view
        streamingMessageElement = document.querySelector(`.message[data-message-id="${messageId}"]`);
        if (streamingMessageElement) {
            contentElement = streamingMessageElement.querySelector('.message-content');
        }
        
        // For comparison view (find in columns)
        if (!contentElement && currentViewMode === 'comparison') {
            const columnElement = document.querySelector(`.comparison-column[data-message-id="${messageId}"]`);
            if (columnElement) {
                contentElement = columnElement.querySelector('.comparison-content');
            }
        }
        
        // Wy≈õlij ≈ºƒÖdanie z parametrem stream:true
        const chatResponse = await fetch(chatUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey.trim()}`,
                'Referer': window.location.origin,
                'X-Title': 'Chat SS'
            },
            body: JSON.stringify({
                model: modelId,
                messages: modelMessages,
                stream: true
            }),
            credentials: 'omit',
            mode: 'cors',
            signal: streamController.signal
        });
        
        if (!chatResponse.ok) {
            throw new Error(`API error: ${chatResponse.status} ${chatResponse.statusText}`);
        }
        
        // Odczytuj dane w formacie SSE (Server-Sent Events)
        const reader = chatResponse.body.getReader();
        const decoder = new TextDecoder("utf-8");
        
        let fullResponse = '';
        let chunkCounter = 0;
        let startTime = Date.now();
        let approxTotalChunks = 100; // Przybli≈ºona liczba chunk√≥w - bƒôdzie aktualizowana
        let tokensPerSecond = modelInfo?.token_rate?.tokens_per_second || 20; // Domy≈õlne tokeny/s
        
        // Szacujemy w przybli≈ºeniu ile token√≥w mo≈ºe zawieraƒá odpowied≈∫, bazujƒÖc na tokensPerSecond
        let estimatedTokens = tokensPerSecond * 10; // Zak≈Çadamy ≈õrednio 10 sekund generowania
        approxTotalChunks = estimatedTokens / 5; // Zak≈Çadamy oko≈Ço 5 token√≥w na chunk
        
        while (true) {
            try {
                const { done, value } = await reader.read();
                if (done) break;
                
                // Dekoduj chunk danych
                const chunk = decoder.decode(value, { stream: true });
                
                // Przetw√≥rz dane SSE (format: "data: {json}\n\n")
                const lines = chunk.split("\n");
                let jsonData = null;
                
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        if (line.includes('[DONE]')) continue;
                        
                        try {
                            const jsonText = line.substring(6); // Usu≈Ñ "data: "
                            jsonData = JSON.parse(jsonText);
                            
                            // Pobierz tekst z odpowiedzi
                            const content = jsonData.choices[0]?.delta?.content || '';
                            
                            // Po≈ÇƒÖcz z dotychczasowƒÖ odpowiedziƒÖ
                            fullResponse += content;
                            
                            // Aktualizuj odpowied≈∫ w historii konwersacji
                            responseMessage.content = fullResponse;
                            
                            // Aktualizuj odpowied≈∫ bezpo≈õrednio w DOM dla lepszej wydajno≈õci
                            if (contentElement) {
                                // Renderuj markdown dla nowej zawarto≈õci
                                contentElement.innerHTML = marked.parse(fullResponse);
                                
                                // Zastosuj pod≈õwietlanie sk≈Çadni dla blok√≥w kodu
                                contentElement.querySelectorAll('pre code').forEach((block) => {
                                    hljs.highlightElement(block);
                                });
                                
                                // Przewi≈Ñ czat w d√≥≈Ç, je≈õli jeste≈õmy w widoku standardowym
                                if (currentViewMode === 'standard') {
                                    chatMessages.scrollTop = chatMessages.scrollHeight;
                                }
                            }
                            
                            // Aktualizuj wska≈∫nik postƒôpu
                            chunkCounter++;
                            const elapsedTime = Date.now() - startTime;
                            const progressElement = document.getElementById('progress-indicator');
                            const progressTextElement = document.getElementById('progress-text');
                            
                            if (progressElement && progressTextElement) {
                                // Dynamiczne dostosowanie szacowanej liczby chunk√≥w
                                if (elapsedTime > 3000) { // Po 3 sekundach mamy lepsze oszacowanie
                                    const rate = chunkCounter / (elapsedTime / 1000);
                                    // Zak≈Çadamy ≈ºe ≈õredni czas generowania to oko≈Ço 15 sekund
                                    approxTotalChunks = Math.max(rate * 15, chunkCounter + 5);
                                }
                                
                                const progressPercent = Math.min(100, Math.round(chunkCounter / approxTotalChunks * 100));
                                progressElement.style.width = `${progressPercent}%`;
                                progressTextElement.textContent = `Generowanie: ${progressPercent}% (${chunkCounter} chunk√≥w)`;
                            }
                        } catch (e) {
                            console.error('B≈ÇƒÖd parsowania JSON ze strumienia:', e);
                        }
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Strumieniowanie zosta≈Ço anulowane');
                    responseMessage.content += '\n\n*Generowanie zosta≈Ço przerwane przez u≈ºytkownika.*';
                    break;
                } else {
                    throw error;
                }
            }
        }
        
        // Zako≈Ñczenie strumieniowania
        isStreaming = false;
        streamController = null;
        
        // Aktualizacja do finalnej wersji
        if (contentElement) {
            contentElement.innerHTML = marked.parse(responseMessage.content);
            
            // Zastosuj pod≈õwietlanie sk≈Çadni dla blok√≥w kodu
            contentElement.querySelectorAll('pre code').forEach((block) => {
                hljs.highlightElement(block);
            });
        }
        
        // Zapisz zaktualizowanƒÖ historiƒô konwersacji
        localStorage.setItem(STORAGE_KEY_HISTORY, JSON.stringify(conversationHistory));
        
        // Rerender views to ensure everything is updated correctly
        renderCurrentView();
        
    } catch (error) {
        console.error(`Error with model ${modelId}:`, error);
        
        // Add error message to conversation for this specific model
        conversationHistory.push({
            role: 'assistant',
            content: `B≈ÇƒÖd komunikacji z modelem: ${error.message}`,
            model: modelId
        });
        
        localStorage.setItem(STORAGE_KEY_HISTORY, JSON.stringify(conversationHistory));
        renderCurrentView();
    } finally {
        isStreaming = false;
    }
}

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
            else return (bytes / 1048576).toFixed(1) + ' MB';
        }

function formatFileSize(bytes) {
    if (bytes < 1024) return bytes + ' B';
    else if (bytes < 1048576) return (bytes / 1024).toFixed(1) + ' KB';
    else return (bytes / 1048576).toFixed(1) + ' MB';
}

// Dodaj te dwie nowe funkcje tutaj:
function createStopGenerationButton() {
    // Usu≈Ñ istniejƒÖcy przycisk, je≈õli istnieje
    removeStopGenerationButton();
    
    // Kontener dla przycisku i wska≈∫nika postƒôpu
    const stopContainer = document.createElement('div');
    stopContainer.id = 'stop-generation-container';
    stopContainer.style.display = 'flex';
    stopContainer.style.alignItems = 'center';
    stopContainer.style.justifyContent = 'center';
    stopContainer.style.margin = '10px 0';
    stopContainer.style.padding = '10px';
    stopContainer.style.borderRadius = '8px';
    stopContainer.style.backgroundColor = 'var(--model-msg-bg)';
    
    // Przycisk zatrzymania
    const stopButton = document.createElement('button');
    stopButton.id = 'stop-generation-button';
    stopButton.textContent = 'Zatrzymaj generowanie';
    stopButton.className = 'send-button';
    stopButton.style.backgroundColor = '#f44336';
    stopButton.style.marginRight = '10px';
    
    stopButton.addEventListener('click', () => {
        if (streamController) {
            streamController.abort();
            stopContainer.innerHTML = '<div style="color: var(--text-color);">Generowanie przerwane przez u≈ºytkownika</div>';
            setTimeout(() => {
                removeStopGenerationButton();
            }, 2000);
        }
    });
    
    // Wska≈∫nik postƒôpu
    const progressContainer = document.createElement('div');
    progressContainer.id = 'stream-progress';
    progressContainer.style.display = 'flex';
    progressContainer.style.flexDirection = 'column';
    progressContainer.style.alignItems = 'flex-start';
    progressContainer.style.flex = '1';
    
    const progressBar = document.createElement('div');
    progressBar.style.width = '100%';
    progressBar.style.height = '8px';
    progressBar.style.backgroundColor = 'var(--border-color)';
    progressBar.style.borderRadius = '4px';
    progressBar.style.overflow = 'hidden';
    progressBar.style.marginBottom = '5px';
    
    const progressIndicator = document.createElement('div');
    progressIndicator.id = 'progress-indicator';
    progressIndicator.style.width = '0%';
    progressIndicator.style.height = '100%';
    progressIndicator.style.backgroundColor = 'var(--primary-color)';
    progressIndicator.style.transition = 'width 0.3s ease';
    
    const progressText = document.createElement('div');
    progressText.id = 'progress-text';
    progressText.style.fontSize = '12px';
    progressText.style.color = 'var(--text-color)';
    progressText.textContent = 'Generowanie odpowiedzi...';
    
    progressBar.appendChild(progressIndicator);
    progressContainer.appendChild(progressBar);
    progressContainer.appendChild(progressText);
    
    stopContainer.appendChild(stopButton);
    stopContainer.appendChild(progressContainer);
    
    // Dodaj do widoku chatMessages
    chatMessages.appendChild(stopContainer);
    chatMessages.scrollTop = chatMessages.scrollHeight;
}

function removeStopGenerationButton() {
    const stopContainer = document.getElementById('stop-generation-container');
    if (stopContainer) {
        stopContainer.remove();
    }
}

        function clearHistory() {
            if (confirm('Czy na pewno chcesz wyczy≈õciƒá ca≈ÇƒÖ historiƒô konwersacji?')) {
                conversationHistory = [];
                ratings = {};
                bestAnswers = {};
                localStorage.removeItem(STORAGE_KEY_HISTORY);
                localStorage.removeItem(STORAGE_KEY_RATINGS);
                localStorage.removeItem(STORAGE_KEY_BEST_ANSWERS);
                renderCurrentView();
            }
        }

        function exportHistory() {
            if (conversationHistory.length === 0) {
                alert('Brak historii konwersacji do wyeksportowania.');
                return;
            }
            
            // Create export data with conversation, ratings, and best answers
            const exportData = {
                conversationHistory,
                ratings,
                bestAnswers,
                exportDate: new Date().toISOString()
            };
            
            const historyJson = JSON.stringify(exportData, null, 2);
            const blob = new Blob([historyJson], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'chat-ss-history.json';
            document.body.appendChild(a);
            a.click();
            
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 0);
        }
        
        // Nowa metoda do testowania klucza API bezpo≈õrednio
        function testAPIConnection() {
            if (!apiKey) {
                debugInfo.innerHTML = "Brak klucza API do testowania";
                debugInfo.style.display = "block";
                return;
            }

            debugInfo.innerHTML = "Testowanie po≈ÇƒÖczenia...";
            debugInfo.style.display = "block";
            
            // Spr√≥buj ka≈ºdego z endpoint√≥w
            let successfulEndpoint = null;
            let allErrors = [];
            
            // Funkcja pomocnicza do testowania pojedynczego endpointu
            const testEndpoint = async (endpoint) => {
                try {
                    // Korekta formatu klucza - upewnijmy siƒô, ≈ºe nie ma bia≈Çych znak√≥w
                    const cleanKey = apiKey.trim();
                    
                    // Wy≈õwietl pierwszy fragment klucza do weryfikacji
                    const keyFragment = cleanKey.substring(0, 4) + "..." + cleanKey.substring(cleanKey.length - 4);
                    debugInfo.innerHTML += `<br>Testowanie endpointu: ${endpoint}<br>Fragment klucza: ${keyFragment}`;
                    
                    let url = endpoint;
                    // U≈ºyj dedykowanego endpointu do weryfikacji klucza, je≈õli jest dostƒôpny
                    if (endpoint.includes('/auth/key')) {
                        url = endpoint;
                    } else {
                        url = `${endpoint}/models`;
                    }
                    
                    const headers = {
                        'Authorization': `Bearer ${cleanKey}`,
                        'Content-Type': 'application/json'
                    };
                    
                    // Dodaj te nag≈Ç√≥wki tylko je≈õli nie u≈ºywamy endpointu auth
                    if (!endpoint.includes('/auth/key')) {
                        headers['Referer'] = window.location.origin;
                        headers['X-Title'] = 'Chat SS Debug';
                    }
                    
                    // Zr√≥b zapytanie testowe
                    const response = await fetch(url, {
                        method: 'GET',
                        headers: headers,
                        // Wy≈ÇƒÖcz credentials aby zredukowaƒá problemy z CORS
                        credentials: 'omit', 
                        mode: 'cors'
                    });
                    
                    const responseText = await response.text();
                    
                    if (response.ok) {
                        successfulEndpoint = endpoint;
                        debugInfo.innerHTML += `<br>‚úÖ Po≈ÇƒÖczenie udane z: ${endpoint}<br>Status: ${response.status}<br>`;
                        // Spr√≥buj sparsowaƒá jako JSON aby wy≈õwietliƒá wiƒôcej informacji
                        try {
                            const jsonResponse = JSON.parse(responseText);
                            if (jsonResponse && typeof jsonResponse === 'object') {
                                debugInfo.innerHTML += `<br>Odpowied≈∫ API: ${JSON.stringify(jsonResponse).substring(0, 100)}...<br>`;
                            }
                        } catch (e) {
                            debugInfo.innerHTML += `<br>Otrzymano odpowied≈∫ (nie JSON)<br>`;
                        }
                        return true;
                    } else {
                        debugInfo.innerHTML += `<br>‚ùå B≈ÇƒÖd z: ${endpoint}<br>Status: ${response.status}<br>`;
                        allErrors.push(`${endpoint}: ${response.status} - ${responseText}`);
                        return false;
                    }
                } catch (error) {
                    debugInfo.innerHTML += `<br>‚ùå WyjƒÖtek dla: ${endpoint}<br>B≈ÇƒÖd: ${error.message}<br>`;
                    allErrors.push(`${endpoint}: ${error.message}`);
                    return false;
                }
            };
            
            // Funkcja g≈Ç√≥wna do przetestowania wszystkich endpoint√≥w
            const testAllEndpoints = async () => {
                for (const endpoint of API_ENDPOINTS) {
                    const success = await testEndpoint(endpoint);
                    if (success) {
                        break; // Znaleziono dzia≈ÇajƒÖcy endpoint, przerwij pƒôtlƒô
                    }
                }
                
                if (successfulEndpoint) {
                    // Znaleziono dzia≈ÇajƒÖcy endpoint, u≈ºyj go
                    debugInfo.innerHTML += `<br><strong>Znaleziono dzia≈ÇajƒÖcy endpoint: ${successfulEndpoint}</strong><br>`;
                    
                    // Zapisz dzia≈ÇajƒÖcy endpoint jako preferowany
                    localStorage.setItem('preferred_endpoint', successfulEndpoint);
                    
                    // Zrestartuj ≈Çadowanie modeli z nowym endpointem
                    fetchModels(successfulEndpoint);
                } else {
                    // ≈ªaden endpoint nie zadzia≈Ça≈Ç
                    debugInfo.innerHTML += `<br><strong>Wszystkie pr√≥by po≈ÇƒÖczenia zawiod≈Çy. Sprawd≈∫ sw√≥j klucz API.</strong><br>`;
                    debugInfo.innerHTML += `<br>Szczeg√≥≈Çy b≈Çƒôd√≥w:<br>${allErrors.join('<br>')}<br>`;
                    debugInfo.innerHTML += `<br><strong>Sugestie rozwiƒÖzania:</strong><br>`;
                    debugInfo.innerHTML += `1. Upewnij siƒô, ≈ºe klucz API jest poprawny i aktywny<br>`;
                    debugInfo.innerHTML += `2. Sprawd≈∫ czy nie ma problem√≥w z po≈ÇƒÖczeniem internetowym<br>`;
                    debugInfo.innerHTML += `3. Spr√≥buj u≈ºyƒá innej przeglƒÖdarki lub urzƒÖdzenia<br>`;
                    debugInfo.innerHTML += `4. Mo≈ºliwe, ≈ºe API OpenRouter ma chwilowe problemy - spr√≥buj p√≥≈∫niej<br>`;
                }
            };
            
            // Uruchom testy
            testAllEndpoints();
        }
		function sortModels(sortOption) {
    if (!models || models.length === 0) return;
    
    const currentSortOption = sortOption || document.getElementById('model-sort').value;
    
    switch (currentSortOption) {
        case 'free':
            // Sortuj darmowe modele najpierw (domy≈õlne)
            models.sort((a, b) => {
                const aIsFree = isModelFree(a);
                const bIsFree = isModelFree(b);
                
                if (aIsFree && !bIsFree) return -1;
                if (!aIsFree && bIsFree) return 1;
                
                // Je≈õli oba majƒÖ ten sam status free/paid, sortuj alfabetycznie
                return (a.name || a.id).localeCompare(b.name || b.id);
            });
            break;
            
        case 'name-asc':
            // Sortuj alfabetycznie rosnƒÖco
            models.sort((a, b) => (a.name || a.id).localeCompare(b.name || b.id));
            break;
            
        case 'name-desc':
            // Sortuj alfabetycznie malejƒÖco
            models.sort((a, b) => (b.name || b.id).localeCompare(a.name || a.id));
            break;
            
        case 'price-asc':
            // Sortuj po cenie rosnƒÖco
            models.sort((a, b) => {
                const aPromptPrice = getModelPromptPrice(a);
                const bPromptPrice = getModelPromptPrice(b);
                
                if (aPromptPrice === bPromptPrice) {
                    const aCompletionPrice = getModelCompletionPrice(a);
                    const bCompletionPrice = getModelCompletionPrice(b);
                    return aCompletionPrice - bCompletionPrice;
                }
                
                return aPromptPrice - bPromptPrice;
            });
            break;
            
        case 'price-desc':
            // Sortuj po cenie malejƒÖco
            models.sort((a, b) => {
                const aPromptPrice = getModelPromptPrice(a);
                const bPromptPrice = getModelPromptPrice(b);
                
                if (aPromptPrice === bPromptPrice) {
                    const aCompletionPrice = getModelCompletionPrice(a);
                    const bCompletionPrice = getModelCompletionPrice(b);
                    return bCompletionPrice - aCompletionPrice;
                }
                
                return bPromptPrice - aPromptPrice;
            });
            break;
            
        case 'default':
        default:
            // Domy≈õlne sortowanie z OpenRouter
            models.sort((a, b) => {
                const aIsFree = isModelFree(a);
                const bIsFree = isModelFree(b);
                
                if (aIsFree && !bIsFree) return -1;
                if (!aIsFree && bIsFree) return 1;
                
                return 0;
            });
			
            break;
			case 'free-in-name':
    // Sortuj modele, kt√≥re majƒÖ "free" w nazwie, na poczƒÖtku
    models.sort((a, b) => {
        const aName = (a.name || a.id).toLowerCase();
        const bName = (b.name || b.id).toLowerCase();
        
        const aHasFree = aName.includes('free');
        const bHasFree = bName.includes('free');
        
        if (aHasFree && !bHasFree) return -1;
        if (!aHasFree && bHasFree) return 1;
        
        // Je≈õli oba majƒÖ lub nie majƒÖ "free" w nazwie, sortuj alfabetycznie
        return aName.localeCompare(bName);
    });
    break;
    }
    
    renderModels();
}

// Funkcje pomocnicze do sortowania po cenie
function getModelPromptPrice(model) {
    if (!model || !model.pricing || !model.pricing.prompt) return Number.MAX_VALUE;
    
    const price = parseFloat(model.pricing.prompt);
    return isNaN(price) ? Number.MAX_VALUE : price;
}

function getModelCompletionPrice(model) {
    if (!model || !model.pricing || !model.pricing.completion) return Number.MAX_VALUE;
    
    const price = parseFloat(model.pricing.completion);
    return isNaN(price) ? Number.MAX_VALUE : price;
}
    </script>
</body>
</html>
